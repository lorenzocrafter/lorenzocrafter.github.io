<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Infinity</title>
    <link href="https://fonts.googleapis.com/css2?family=Bruno+Ace+SC&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root {
            --primary: #00f3ff;
            --accent: #ff0055;
            --bg: #000205;
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Bruno Ace SC', cursive; color: white; user-select: none; }
        #canvas-container { position: absolute; inset: 0; z-index: 1; }

        /* UI */
        #ui-layer {
            position: absolute; inset: 0; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        .hud-top {
            position: absolute; top: 0; left: 0; width: 100%; padding: 30px;
            display: flex; justify-content: space-between; pointer-events: none;
        }

        .stat-box {
            text-align: center; text-shadow: 0 0 15px var(--primary);
        }
        .stat-label { font-family: 'Rajdhani'; font-size: 0.9rem; opacity: 0.8; letter-spacing: 2px; color: var(--primary); }
        .stat-value { font-size: 2.5rem; line-height: 1; }

        .screen {
            background: rgba(0, 2, 5, 0.9); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1); border-top: 2px solid var(--primary); border-bottom: 2px solid var(--accent);
            box-shadow: 0 0 60px rgba(0, 243, 255, 0.1);
            padding: 50px; width: 90%; max-width: 600px;
            display: none; flex-direction: column; gap: 20px; align-items: center; text-align: center;
            pointer-events: auto; transform: scale(0.95); opacity: 0; transition: 0.4s ease;
        }
        .screen.active { display: flex; transform: scale(1); opacity: 1; }

        h1 {
            font-size: 4rem; margin: 0; line-height: 0.9;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 25px var(--primary));
        }

        button {
            background: transparent; border: 1px solid var(--primary); color: var(--primary);
            padding: 15px 50px; font-family: 'Bruno Ace SC'; font-size: 1.2rem; cursor: pointer;
            transition: 0.3s; text-transform: uppercase; letter-spacing: 2px; position: relative; overflow: hidden;
        }
        button:hover { background: var(--primary); color: black; box-shadow: 0 0 40px var(--primary); }
        
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; width: 100%; margin: 20px 0; }
        .shop-item {
            border: 1px solid #333; padding: 10px; cursor: pointer; transition: 0.3s; background: rgba(255,255,255,0.02);
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .shop-item:hover { border-color: white; background: rgba(255,255,255,0.1); }
        .shop-item.owned { border-color: var(--primary); }
        .shop-item.equipped { background: rgba(0,243,255,0.15); box-shadow: inset 0 0 15px var(--primary); border-color: var(--primary); }
        .color-dot { width: 20px; height: 20px; border-radius: 50%; box-shadow: 0 0 10px currentColor; }

        /* SPEED LINES */
        .speed-lines {
            position: absolute; inset: 0; background: radial-gradient(circle, transparent 50%, rgba(0,243,255,0.05) 100%);
            pointer-events: none; z-index: 5; mix-blend-mode: screen; display: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="speed-lines" id="speed-fx"></div>

    <div id="ui-layer">
        <div class="hud-top" id="hud" style="display:none;">
            <div class="stat-box" style="text-align:left;">
                <div class="stat-label">DISTANCE</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box" style="text-align:right;">
                <div class="stat-label">CREDITS</div>
                <div class="stat-value" style="color:var(--accent)">$<span id="credits">0</span></div>
            </div>
        </div>

        <div id="menu-screen" class="screen active">
            <h1>NEON<br>INFINITY</h1>
            <div style="font-family:'Rajdhani'; letter-spacing:3px; color:#aaa;">HIGH SCORE: <span id="menu-best">0</span></div>
            <br>
            <button onclick="Game.start()">IGNITE</button>
            <button style="border-color:white; color:white; font-size:0.9rem; padding:10px 30px;" onclick="UI.openShop()">HANGAR</button>
        </div>

        <div id="shop-screen" class="screen">
            <h2 style="color:var(--primary); margin:0;">GARAGE</h2>
            <div style="font-family:'Rajdhani';">CREDITS: $<span id="shop-credits">0</span></div>
            <div class="shop-grid" id="shop-list"></div>
            <button onclick="UI.openMenu()">BACK</button>
        </div>

        <div id="gameover-screen" class="screen">
            <h1 style="font-size:3rem; color:var(--accent); text-shadow:0 0 30px red;">CRASHED</h1>
            <div style="display:flex; gap:40px; justify-content:center;">
                <div>
                    <div class="stat-label">SCORE</div>
                    <div class="stat-value" id="go-score">0</div>
                </div>
                <div>
                    <div class="stat-label">EARNED</div>
                    <div class="stat-value" style="color:var(--primary)" id="go-earned">+0</div>
                </div>
            </div>
            <br>
            <button onclick="Game.start()">RETRY</button>
            <button style="border-color:white; color:white;" onclick="UI.openMenu()">MENU</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const C = {
            tunnelRadius: 40,
            tunnelLength: 2000, // ¡Mucho más largo para ver el fondo!
            segCount: 80,      // Más segmentos visibles
            segLength: 20,
            fogDensity: 0.003, // ¡Niebla muy baja para ver lejos!
            speedBase: 1.0,
            colors: [0x00f3ff, 0xff00aa, 0x00ff66, 0xffea00, 0xffffff]
        };

        const DB = {
            data: { credits: 0, high: 0, unlocked:['c0'], equipped:'c0' },
            ships: [
                { id:'c0', name:'Cyan', color:0x00f3ff, price:0 },
                { id:'c1', name:'Pink', color:0xff00aa, price:200 },
                { id:'c2', name:'Lime', color:0x00ff66, price:500 },
                { id:'c3', name:'Gold', color:0xffea00, price:1000 },
                { id:'c4', name:'White', color:0xffffff, price:2000 }
            ],
            load() { const s=localStorage.getItem('ni_save'); if(s) this.data=JSON.parse(s); },
            save() { localStorage.setItem('ni_save', JSON.stringify(this.data)); },
            getColor() { return this.ships.find(s=>s.id===this.data.equipped).color; }
        };

        const UI = {
            els: {},
            init() {
                ['menu','shop','gameover','hud'].forEach(k => this.els[k] = document.getElementById(k+'-screen') || document.getElementById(k));
                ['score','credits','menu-best','shop-credits','go-score','go-earned'].forEach(k => this.els[k] = document.getElementById(k));
                this.els.shopList = document.getElementById('shop-list');
                DB.load();
                this.update();
            },
            show(k) {
                Object.values(this.els).forEach(e => { if(e.classList) e.classList.remove('active'); e.style.display = 'none'; });
                if(k==='hud') { this.els.hud.style.display = 'flex'; document.getElementById('speed-fx').style.display='block'; }
                else { this.els[k].style.display = 'flex'; setTimeout(()=>this.els[k].classList.add('active'), 10); document.getElementById('speed-fx').style.display='none'; }
            },
            update() {
                this.els['menu-best'].innerText = Math.floor(DB.data.high);
                this.els['credits'].innerText = DB.data.credits;
                this.els['shop-credits'].innerText = DB.data.credits;
            },
            openMenu() { this.update(); this.show('menu'); },
            openShop() {
                this.els.shopList.innerHTML = '';
                DB.ships.forEach(s => {
                    const has = DB.data.unlocked.includes(s.id);
                    const eq = DB.data.equipped === s.id;
                    const d = document.createElement('div');
                    d.className = `shop-item ${eq?'equipped':''} ${has?'owned':''}`;
                    d.innerHTML = `<div class="color-dot" style="background:#${s.color.toString(16)};color:#${s.color.toString(16)}"></div><div style="font-family:'Rajdhani'; font-weight:bold">${s.name}</div><div style="font-size:0.8rem; opacity:0.7">${has?(eq?'READY':'OWNED'):'$'+s.price}</div>`;
                    d.onclick = () => {
                        if(has) { DB.data.equipped=s.id; DB.save(); this.openShop(); }
                        else if(DB.data.credits>=s.price) {
                            DB.data.credits-=s.price; DB.data.unlocked.push(s.id); DB.data.equipped=s.id; DB.save(); this.openShop();
                        }
                    };
                    this.els.shopList.appendChild(d);
                });
                this.show('shop');
            }
        };

        class Engine {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000205, C.fogDensity);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: false }); // Performance over AA for bloom
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // POST PROCESSING
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.8));

                // LIGHTS
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.2));
                const dl = new THREE.DirectionalLight(0xffffff, 1);
                dl.position.set(0, 20, 0);
                this.scene.add(dl);

                // GROUPS
                this.world = new THREE.Group();
                this.scene.add(this.world);
                this.playerGroup = new THREE.Group();
                this.scene.add(this.playerGroup);

                this.state = { playing: false, speed: 0, angle: -Math.PI/2, vel: 0, score: 0, dist: 0 };
                this.keys = { l:false, r:false };
                this.segments = []; this.obstacles = []; this.coins = [];

                this.initWorld();
                this.createPlayer();
                this.events();
                
                UI.init();
                UI.openMenu();
                this.loop();
            }

            createPlayer() {
                // NAVE MEJORADA (Estilo TRON Jet)
                while(this.playerGroup.children.length) this.playerGroup.remove(this.playerGroup.children[0]);
                
                const c = DB.getColor();
                
                // Chasis Central
                const body = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 6, 4),
                    new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.8 })
                );
                body.rotation.x = Math.PI/2;
                body.rotation.y = Math.PI/4;
                this.playerGroup.add(body);

                // Alas Brillantes
                const wings = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 0.1, 2),
                    new THREE.MeshBasicMaterial({ color: c }) // Color emisivo fuerte
                );
                wings.position.set(0, 0, 1);
                this.playerGroup.add(wings);

                // Motor
                const eng = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.2, 1, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                eng.rotation.x = Math.PI/2;
                eng.position.z = 3.5;
                this.playerGroup.add(eng);
            }

            initWorld() {
                // Crear segmentos iniciales
                for(let i=0; i<C.segCount; i++) this.spawnSeg(-i * C.segLength);
            }

            spawnSeg(z) {
                // WIREFRAME TUNNEL
                const pts = [];
                const r = C.tunnelRadius;
                const segs = 8; // Octágono
                for(let i=0; i<=segs; i++) {
                    const t = (i/segs)*Math.PI*2;
                    pts.push(new THREE.Vector3(Math.cos(t)*r, Math.sin(t)*r, 0));
                }
                const geo = new THREE.BufferGeometry().setFromPoints(pts);
                const mat = new THREE.LineBasicMaterial({ color: 0x222222, transparent:true, opacity:0.4 });
                
                // Lineas maestras (Brillantes)
                if(Math.abs(z) % 100 < 20) { mat.color.setHex(0x444444); mat.opacity=0.8; }

                const l = new THREE.Line(geo, mat);
                l.position.z = z;
                this.world.add(l);
                this.segments.push(l);

                // Spawns (Obstáculos y Monedas)
                if(z < -200 && Math.random() < 0.35) this.spawnObj(z);
            }

            spawnObj(z) {
                const isObs = Math.random() > 0.25;
                const angle = Math.floor(Math.random()*8)*(Math.PI/4);
                const r = C.tunnelRadius - 4;
                const x = Math.cos(angle)*r;
                const y = Math.sin(angle)*r;

                if(isObs) {
                    // Obstáculo: NEON WALL
                    const geo = new THREE.BoxGeometry(8, 2, 1);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xff0044 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x, y, z);
                    m.rotation.z = angle + Math.PI/2;
                    m.userData = { angle };
                    this.world.add(m);
                    this.obstacles.push(m);
                    
                    // Glow effect (PointLight barato)
                    // Solo agregamos luz a algunos para rendimiento
                    if(Math.random() > 0.5) {
                       // ... (omitido por rendimiento, el bloom ya hace el trabajo)
                    }

                } else {
                    // Moneda
                    const geo = new THREE.OctahedronGeometry(1.5);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffea00 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x*0.9, y*0.9, z);
                    m.userData = { angle, rot: Math.random() };
                    this.world.add(m);
                    this.coins.push(m);
                }
            }

            events() {
                const set = (k, v) => { if(k==='ArrowLeft') this.keys.l=v; if(k==='ArrowRight') this.keys.r=v; };
                window.onkeydown = e => set(e.key, true);
                window.onkeyup = e => set(e.key, false);
                window.onresize = () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                };
                // Touch logic simplified
                const tl = document.createElement('div'); tl.style.cssText='position:absolute;bottom:0;left:0;width:50%;height:50%;z-index:20';
                const tr = document.createElement('div'); tr.style.cssText='position:absolute;bottom:0;right:0;width:50%;height:50%;z-index:20';
                document.body.append(tl, tr);
                tl.ontouchstart=e=>{e.preventDefault();this.keys.l=true}; tl.ontouchend=()=>{this.keys.l=false};
                tr.ontouchstart=e=>{e.preventDefault();this.keys.r=true}; tr.ontouchend=()=>{this.keys.r=false};
            }

            start() {
                this.createPlayer();
                this.state = { playing: true, speed: C.speedBase, score: 0, angle: -Math.PI/2, vel: 0 };
                // Limpieza
                this.obstacles.forEach(o=>this.world.remove(o)); this.obstacles=[];
                this.coins.forEach(c=>this.world.remove(c)); this.coins=[];
                UI.show('hud');
            }

            gameover() {
                this.state.playing = false;
                if(this.state.score > DB.data.high) DB.data.high = this.state.score;
                DB.save();
                UI.els['go-score'].innerText = Math.floor(this.state.score);
                UI.els['go-earned'].innerText = '+' + Math.floor(this.state.score/10);
                DB.data.credits += Math.floor(this.state.score/10);
                DB.save();
                UI.show('gameover');
            }

            loop() {
                requestAnimationFrame(() => this.loop());

                if(this.state.playing) {
                    // 1. PHYSICS & MOVEMENT
                    const acc = 0.006; 
                    const friction = 0.9;
                    if(this.keys.l) this.state.vel += acc;
                    if(this.keys.r) this.state.vel -= acc;
                    this.state.vel *= friction;
                    this.state.angle += this.state.vel;

                    const r = C.tunnelRadius - 8;
                    const px = Math.cos(this.state.angle) * r;
                    const py = Math.sin(this.state.angle) * r;
                    
                    this.playerGroup.position.set(px, py, 0);
                    this.playerGroup.rotation.z = this.state.angle - Math.PI/2;
                    this.playerGroup.rotation.y = this.state.vel * 6; // Banking agressivo
                    
                    // 2. CAMERA (DYNAMIC FOV & SMOOTH FOLLOW)
                    // Aumentamos FOV con la velocidad
                    const targetFov = 80 + (this.state.speed * 5);
                    this.camera.fov += (targetFov - this.camera.fov) * 0.05;
                    this.camera.updateProjectionMatrix();

                    const cx = Math.cos(this.state.angle) * (r - 18); // Más adentro
                    const cy = Math.sin(this.state.angle) * (r - 18);
                    this.camera.position.x += (cx - this.camera.position.x) * 0.1;
                    this.camera.position.y += (cy - this.camera.position.y) * 0.1;
                    this.camera.position.z = 30; // Distancia perfecta
                    this.camera.lookAt(0, 0, -150); // Mirar lejos
                    this.camera.rotation.z = (this.state.angle - Math.PI/2) * 0.5;

                    // 3. WORLD SCROLL
                    const spd = this.state.speed;
                    this.state.score += spd * 0.2;
                    this.state.speed += 0.0003;

                    // Segments
                    this.segments.forEach(s => {
                        s.position.z += spd;
                        if(s.position.z > 30) {
                            s.position.z -= (this.segments.length * C.segLength);
                            if(Math.random()<0.4) this.spawnObj(s.position.z);
                        }
                    });

                    // Obstacles
                    for(let i=this.obstacles.length-1; i>=0; i--) {
                        const o = this.obstacles[i];
                        o.position.z += spd;
                        
                        // Collision Logic
                        if(o.position.z > -5 && o.position.z < 5) {
                            let diff = Math.abs(this.state.angle - o.userData.angle) % (Math.PI*2);
                            if(diff > Math.PI) diff = (Math.PI*2) - diff;
                            if(diff < 0.5) this.gameover();
                        }
                        
                        if(o.position.z > 30) { this.world.remove(o); this.obstacles.splice(i, 1); }
                    }

                    // Coins
                    for(let i=this.coins.length-1; i>=0; i--) {
                        const c = this.coins[i];
                        c.position.z += spd;
                        c.rotation.y += 0.1;
                        
                        if(c.position.z > -5 && c.position.z < 5) {
                            let diff = Math.abs(this.state.angle - c.userData.angle) % (Math.PI*2);
                            if(diff > Math.PI) diff = (Math.PI*2) - diff;
                            if(diff < 0.7) {
                                DB.data.credits += 10;
                                this.world.remove(c);
                                this.coins.splice(i, 1);
                                continue;
                            }
                        }
                        if(c.position.z > 30) { this.world.remove(c); this.coins.splice(i, 1); }
                    }

                    UI.els.score.innerText = Math.floor(this.state.score);
                    UI.els.credits.innerText = DB.data.credits;

                } else {
                    this.world.rotation.z += 0.001;
                }

                this.composer.render();
            }
        }

        window.onload = () => window.Game = new Engine();

    </script>
</body>
</html>
