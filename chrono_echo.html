<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrono-Echo: Invasión | Blox Games</title>
    <style>
        body {
            margin: 0;
            background-color: #0a0a14; /* Fondo más oscuro */
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        h1 {
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #4d9eff;
            text-shadow: 0 0 10px rgba(77, 158, 255, 0.5);
            font-size: 24px;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            border: 3px solid #222;
            background-image: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(50, 0, 0, 0.9); /* Fondo rojizo al morir */
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        button {
            background: #4d9eff;
            border: 1px solid #fff;
            color: #fff;
            padding: 12px 25px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 25px;
            box-shadow: 0 0 10px #4d9eff;
        }

        button:hover {
            background: #fff;
            color: #1a1a2e;
        }
        
        .instructions {
            font-size: 12px; opacity: 0.8; margin-top: 5px; text-align: center;
            color: #aaa;
        }
    </style>
</head>
<body>

    <h1>Chrono-Echo: Invasión</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="700" height="500"></canvas>
        <div id="ui">Orbes: <span id="scoreVal">0</span></div>
        
        <div id="gameOverScreen">
            <h2 style="color: #ff3333; font-size: 32px; margin-bottom: 10px;">FIN DEL BUCLE</h2>
            <p id="deathCause" style="color: #ffaaaa;">Causa de muerte desconocida</p>
            <p>Orbes recolectados: <span id="finalScore">0</span></p>
            <button onclick="resetGame()">Reintentar Misión</button>
        </div>
    </div>

    <p class="instructions">
        [WASD / FLECHAS]: Moverse <br>
        [ESPACIO]: Disparar <br>
        Objetivo: Recoge Orbes Azules. Evita a los Zombies Rojos y a tus propios Ecos pasados.
    </p>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreVal');
    const finalScoreEl = document.getElementById('finalScore');
    const deathCauseEl = document.getElementById('deathCause');
    const gameOverScreen = document.getElementById('gameOverScreen');

    // --- Configuración Global ---
    const TILE_SIZE = 24; // Tamaño base para los sprites
    let isGameOver = false;
    let score = 0;
    let frames = 0;

    // --- El Jugador ---
    let player = { 
        x: canvas.width/2, 
        y: canvas.height/2, 
        speed: 4, 
        color: '#4d9eff', // Azul soldado
        lastDir: {x: 1, y: 0} // Para saber dónde disparar si está quieto
    };
    let velocity = { x: 0, y: 0 };

    // --- Sistema de Grabación (Ecos) ---
    // currentRecording guardará objetos: { x, y, didShoot (booleano) }
    let currentRecording = []; 
    // echoes será un array de recordings completas
    let echoes = []; 

    // --- Objetos del Mundo ---
    let goal = { x: 0, y: 0, size: 18, active: false };
    let bullets = [];
    let enemies = [];
    let enemySpawnRate = 100; // Frames entre spawns de zombies (menor = más difícil)

    // --- Input ---
    const keys = {};
    let spacePressedPreviously = false; // Para detectar el "tap" de disparo único

    window.addEventListener('keydown', (e) => keys[e.key] = true);
    window.addEventListener('keyup', (e) => keys[e.key] = false);

    // --- Funciones Auxiliares ---
    function checkCollision(rect1, rect2, size1, size2) {
        return (
            rect1.x < rect2.x + size2 &&
            rect1.x + size1 > rect2.x &&
            rect1.y < rect2.y + size2 &&
            rect1.y + size1 > rect2.y
        );
    }

    function spawnGoal() {
        goal.x = Math.random() * (canvas.width - 60) + 30;
        goal.y = Math.random() * (canvas.height - 60) + 30;
        goal.active = true;
    }

    function spawnEnemy() {
        let side = Math.floor(Math.random() * 4);
        let x, y;
        switch(side) {
            case 0: x = -TILE_SIZE; y = Math.random() * canvas.height; break; // Izquierda
            case 1: x = canvas.width; y = Math.random() * canvas.height; break; // Derecha
            case 2: x = Math.random() * canvas.width; y = -TILE_SIZE; break; // Arriba
            case 3: x = Math.random() * canvas.width; y = canvas.height; break; // Abajo
        }
        enemies.push({
            x: x, y: y, speed: Math.random() * 1.5 + 1, color: '#c92a2a'
        });
    }

    function shoot(shooterX, shooterY, dirX, dirY, isEchoShot) {
        let vx = dirX * 8;
        let vy = dirY * 8;
        // Si no se mueve, dispara a la derecha por defecto
        if (vx === 0 && vy === 0) vx = 8; 
        
        bullets.push({
            x: shooterX + TILE_SIZE/2 - 4, // Centrar bala
            y: shooterY + TILE_SIZE/2 - 4,
            vx: vx,
            vy: vy,
            size: 8,
            isEchoShot: isEchoShot,
            color: isEchoShot ? 'rgba(100, 200, 255, 0.5)' : '#fff'
        });
    }

    function createEcho() {
        // Guardamos la grabación actual
        echoes.push({
            recording: JSON.parse(JSON.stringify(currentRecording)),
            currentIndex: 0,
            color: `hsla(${Math.random() * 360}, 70%, 60%, 0.4)` // Fantasma translúcido
        });
        // Reiniciamos grabación
        currentRecording = [];
        // Incrementamos dificultad
        if(enemySpawnRate > 30) enemySpawnRate -= 5;
    }

    // --- Bucle Principal de Lógica ---
    function update() {
        if (isGameOver) return;
        frames++;

        // 1. Movimiento del Jugador
        velocity.x = 0; velocity.y = 0;
        if (keys['ArrowUp'] || keys['w']) velocity.y = -player.speed;
        if (keys['ArrowDown'] || keys['s']) velocity.y = player.speed;
        if (keys['ArrowLeft'] || keys['a']) velocity.x = -player.speed;
        if (keys['ArrowRight'] || keys['d']) velocity.x = player.speed;

        // Guardar última dirección para disparar
        if (velocity.x !== 0 || velocity.y !== 0) {
            player.lastDir = { x: Math.sign(velocity.x), y: Math.sign(velocity.y) };
        }

        player.x += velocity.x;
        player.y += velocity.y;

        // Límites
        if (player.x < 0) player.x = 0;
        if (player.x > canvas.width - TILE_SIZE) player.x = canvas.width - TILE_SIZE;
        if (player.y < 0) player.y = 0;
        if (player.y > canvas.height - TILE_SIZE) player.y = canvas.height - TILE_SIZE;

        // 2. Disparo del Jugador (Detectar pulsación única)
        let shotTriggered = false;
        if (keys[' '] && !spacePressedPreviously) {
            shoot(player.x, player.y, player.lastDir.x, player.lastDir.y, false);
            shotTriggered = true;
        }
        spacePressedPreviously = keys[' '];

        // 3. GRABAR Frame Actual (Posición y si disparó)
        currentRecording.push({ 
            x: player.x, 
            y: player.y,
            didShoot: shotTriggered,
            dirX: player.lastDir.x,
            dirY: player.lastDir.y
        });

        // 4. Actualizar Balas
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx;
            b.y += b.vy;
            // Eliminar si sale de pantalla
            if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
                bullets.splice(i, 1);
            }
        }

        // 5. Actualizar Enemigos (Zombies)
        if (frames % enemySpawnRate === 0) spawnEnemy();

        for (let i = enemies.length - 1; i >= 0; i--) {
            let en = enemies[i];
            // IA básica: Perseguir al jugador
            let dx = player.x - en.x;
            let dy = player.y - en.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
                en.x += (dx/dist) * en.speed;
                en.y += (dy/dist) * en.speed;
            }

            // Colisión Zombie vs Jugador (Muerte)
            if (checkCollision(player, en, TILE_SIZE, TILE_SIZE)) {
                gameOver("Te comió un Zombie.");
            }

            // Colisión Zombie vs Balas
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                if (checkCollision(en, b, TILE_SIZE, b.size)) {
                    // Zombie muere, bala desaparece
                    enemies.splice(i, 1);
                    bullets.splice(j, 1);
                    // Romper el loop de balas porque el enemigo 'i' ya no existe
                    break; 
                }
            }
        }


        // 6. Colisión Jugador vs Orbe (Crear Eco)
        if (goal.active && checkCollision(player, goal, TILE_SIZE, goal.size)) {
            score++;
            scoreEl.innerText = score;
            createEcho();
            spawnGoal();
            goal.active = false; // Pequeña pausa en el spawn
            setTimeout(() => goal.active = true, 500);
        }

        // 7. Actualizar ECOS (La magia del juego)
        for (let i = 0; i < echoes.length; i++) {
            let eco = echoes[i];
            // Obtenemos los datos del frame actual
            let frameData = eco.recording[eco.currentIndex];
            
            // ¿El eco disparó en este frame en el pasado?
            if (frameData.didShoot) {
                shoot(frameData.x, frameData.y, frameData.dirX, frameData.dirY, true);
            }

            // Avanzar el eco
            eco.currentIndex++;
            if (eco.currentIndex >= eco.recording.length) {
                eco.currentIndex = 0; // Loop
            }

            // Colisión Jugador vs Cuerpo del Eco
            // Usamos frameData porque es la posición actual del eco
            if (checkCollision(player, frameData, TILE_SIZE, TILE_SIZE)) {
                 // Buffer de seguridad al inicio del bucle
                if (eco.currentIndex > 30) { 
                     gameOver("Chocaste con tu pasado.");
                }
            }
        }
         // Colisión Jugador vs Balas de Eco
         for (let j = bullets.length - 1; j >= 0; j--) {
            let b = bullets[j];
            if (b.isEchoShot && checkCollision(player, b, TILE_SIZE, b.size)) {
                gameOver("Te disparó tu propio Eco.");
            }
        }
    }

    // --- Funciones de Dibujo (Gráficos mejorados) ---
    
    // Dibuja un "soldado" simple usando rectángulos
    function drawSoldier(x, y, color, isGhost) {
        ctx.save();
        ctx.translate(x, y);
        if (isGhost) ctx.globalAlpha = 0.4;

        // Cuerpo
        ctx.fillStyle = color;
        ctx.fillRect(4, 8, 16, 16); // Torso blindado
        // Cabeza/Casco
        ctx.fillStyle = isGhost ? color : '#334455'; // Casco oscuro si es real
        ctx.fillRect(6, 0, 12, 8);
        // Visor
        ctx.fillStyle = '#00d4ff';
        ctx.fillRect(8, 2, 8, 3);
        
        ctx.restore();
    }

    // Dibuja un "zombie"
    function drawZombie(x, y, color) {
        ctx.save();
        ctx.translate(x, y);
        // Cuerpo deforme
        ctx.fillStyle = color;
        ctx.fillRect(2, 6, 20, 18);
        // Cabeza ladeada
        ctx.fillStyle = '#8a1c1c';
        ctx.fillRect(4, -2, 14, 10);
        // Ojos rojos brillantes
        ctx.fillStyle = 'yellow';
        ctx.fillRect(6, 0, 3, 3);
        ctx.fillRect(13, 1, 3, 3);
        ctx.restore();
    }

    function draw() {
        // Fondo con efecto de barrido
        ctx.fillStyle = 'rgba(26, 26, 46, 0.3)'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dibujar Orbe (Meta)
        if(goal.active) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00d4ff';
            ctx.fillStyle = '#00d4ff';
            ctx.beginPath();
            ctx.arc(goal.x + goal.size/2, goal.y + goal.size/2, goal.size/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // Dibujar Balas
        bullets.forEach(b => {
            ctx.fillStyle = b.color;
            ctx.shadowBlur = b.isEchoShot ? 5 : 10;
            ctx.shadowColor = b.color;
            ctx.fillRect(b.x, b.y, b.size, b.size);
            ctx.shadowBlur = 0;
        });

        // Dibujar Ecos
        echoes.forEach(eco => {
            let pos = eco.recording[eco.currentIndex];
            drawSoldier(pos.x, pos.y, eco.color, true);
        });

        // Dibujar Enemigos
        enemies.forEach(en => {
            drawZombie(en.x, en.y, en.color);
        });

        // Dibujar Jugador (siempre al final para estar arriba)
        drawSoldier(player.x, player.y, player.color, false);
    }

    function loop() {
        update();
        draw();
        if (!isGameOver) requestAnimationFrame(loop);
    }

    function gameOver(cause) {
        if(isGameOver) return; // Evitar múltiples llamadas
        isGameOver = true;
        deathCauseEl.innerText = cause;
        finalScoreEl.innerText = score;
        gameOverScreen.style.display = 'flex';
    }

    function resetGame() {
        isGameOver = false;
        gameOverScreen.style.display = 'none';
        score = 0;
        scoreEl.innerText = '0';
        frames = 0;
        enemySpawnRate = 100;
        
        player.x = canvas.width/2;
        player.y = canvas.height/2;
        
        bullets = [];
        enemies = [];
        echoes = [];
        currentRecording = [];
        
        spawnGoal();
        loop();
    }

    // Iniciar
    spawnGoal();
    loop();

</script>
</body>
</html>
